"use strict";

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.function.name.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

require("core-js/modules/es.object.assign.js");

require("core-js/modules/es.object.keys.js");

require("core-js/modules/es.array.for-each.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.array.reduce.js");

require("core-js/modules/es.array.is-array.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.split.js");

require("core-js/modules/es.array.join.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.array.includes.js");

require("core-js/modules/es.string.includes.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.string.trim.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.object.define-property.js");

var _Pattern = _interopRequireDefault(require("./Pattern"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var PatternStorage = /*#__PURE__*/function () {
  function PatternStorage() {
    _classCallCheck(this, PatternStorage);

    this.definitions = {};
    this.namespaces = {};
    this.globals = {};
    this.patterns = {};
    this.twigResources = {};
  }

  _createClass(PatternStorage, [{
    key: "addGlobal",
    value: function addGlobal(name, value) {
      if (this.globals[name] != null) {
        if (typeof value === 'string') {
          this.globals[name] = value;
        } else {
          this.globals[name] = Object.assign(this.globals[name], value);
        }
      } else {
        this.globals[name] = value;
      }
    }
  }, {
    key: "getGlobals",
    value: function getGlobals() {
      return this.globals;
    }
  }, {
    key: "setNamespaces",
    value: function setNamespaces(namespaces) {
      this.namespaces = namespaces;
    }
  }, {
    key: "getNamespaces",
    value: function getNamespaces() {
      return this.namespaces;
    }
  }, {
    key: "getPatternIds",
    value: function getPatternIds() {
      return Object.keys(this.definitions);
    }
  }, {
    key: "loadPatternsByNamespace",
    value: function loadPatternsByNamespace(namespace) {
      var _this = this;

      var foundPatterns = [];
      Object.keys(this.definitions).forEach(function (key) {
        var pattern = _this.loadPattern(key);

        if (pattern.getNamespace() === namespace) {
          foundPatterns.push(pattern);
        }
      });
      return foundPatterns;
    }
    /**
     * Performs a deep merge of objects and returns new object. Does not modify
     * objects (immutable) and merges arrays via concatenation.
     *
     * @param {...object} objects - Objects to merge
     * @returns {object} New object with merged key/values
     */

  }, {
    key: "mergeDeep",
    value: function mergeDeep() {
      var _this2 = this;

      var isObject = function isObject(obj) {
        return obj && _typeof(obj) === 'object';
      };

      for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
        objects[_key] = arguments[_key];
      }

      return objects.reduce(function (prev, obj) {
        Object.keys(obj).forEach(function (key) {
          var pVal = prev[key];
          var oVal = obj[key];

          if (Array.isArray(pVal) && Array.isArray(oVal)) {
            // eslint-disable-next-line no-param-reassign
            prev[key] = pVal.concat.apply(pVal, _toConsumableArray(oVal));
          } else if (isObject(pVal) && isObject(oVal)) {
            // eslint-disable-next-line no-param-reassign
            prev[key] = _this2.mergeDeep(pVal, oVal);
          } else {
            // eslint-disable-next-line no-param-reassign
            prev[key] = oVal;
          }
        });
        return prev;
      }, {});
    }
  }, {
    key: "extendPatternDefinition",
    value: function extendPatternDefinition(pattern) {
      var _this3 = this;

      var resultingPattern = pattern;

      if (pattern != null && pattern["extends"] != null && pattern["extends"].length !== 0) {
        pattern["extends"].forEach(function (extend) {
          var _extend$split = extend.split('.'),
              _extend$split2 = _slicedToArray(_extend$split, 3),
              basePattern = _extend$split2[0],
              basePatternType = _extend$split2[1],
              basePatternField = _extend$split2[2];

          if (_this3.definitions[basePattern] == null) {
            throw new Error("Base pattern \"".concat(basePattern, "\" not found. Possible patterns ").concat(Object.keys(_this3.definitions).join(', ')));
          }

          var basePatternDefinition = _this3.extendPatternDefinition(_this3.definitions[basePattern]);

          var basePatternTypes = [];

          if (basePatternType == null) {
            basePatternTypes = ['fields', 'settings'];

            if (resultingPattern.use === undefined) {
              resultingPattern.use = basePatternDefinition.use;
            }
          } else {
            basePatternTypes = [basePatternType];
          }

          Object.keys(basePatternTypes).forEach(function (key) {
            var type = basePatternTypes[key];

            if (basePatternField == null) {
              if (basePatternDefinition[type] != null) {
                if (resultingPattern[type] == null) {
                  resultingPattern[type] = {};
                }

                resultingPattern[type] = _this3.mergeDeep(basePatternDefinition[type], resultingPattern[type]);
              }
            } else if (basePatternDefinition[type] != null) {
              if (resultingPattern[type] == null) {
                resultingPattern[type] = [];
              }

              resultingPattern[type][basePatternField] = basePatternDefinition[type][basePatternField];
            }
          });
        });
        resultingPattern["extends"] = [];
      }

      return resultingPattern;
    }
  }, {
    key: "loadPattern",
    value: function loadPattern(patternId) {
      if (this.patterns[patternId] !== undefined) {
        return this.patterns[patternId];
      }

      var definition = this.extendPatternDefinition(this.definitions[patternId]);

      if (definition == null) {
        throw new Error("Pattern definition \"".concat(patternId, "\" not found. Possible pattern ids are: \"").concat(Object.keys(this.definitions).join(' ,'), "\""));
      }

      this.patterns[patternId] = new _Pattern["default"](patternId, definition, this);
      return this.patterns[patternId];
    }
  }, {
    key: "loadVariant",
    value: function loadVariant(patternId, variantId) {
      var pattern = this.loadPattern(patternId);
      return pattern.getVariant(variantId);
    }
  }, {
    key: "createDefinitions",
    value: function createDefinitions(definitions) {
      this.definitions = definitions;
    }
  }, {
    key: "createDefinitionsFromMultiContext",
    value: function createDefinitionsFromMultiContext(any) {
      var _this4 = this;

      Object.keys(this.patterns).forEach(function (key) {
        delete _this4.patterns[key];
      });
      this.patterns = {};

      if (Array.isArray(any) === true) {
        any.forEach(function (context) {
          if (context != null) {
            _this4.createDefinitionsFromContext(context);
          }
        });
      } else {
        this.createDefinitionsFromContext(any);
      }
    }
  }, {
    key: "createDefinitionsFromContext",
    value: function createDefinitionsFromContext(context) {
      var _this5 = this;

      context.keys().forEach(function (key) {
        if (key.includes('__tests__') === false && key.includes('__int_tests__') === false) {
          try {
            var data = context(key);

            if (data.wingsuit != null && _typeof(data.wingsuit.patternDefinition) === 'object') {
              var patternDefinition = data.wingsuit.patternDefinition;
              var namespace = data.wingsuit.namespace;
              var parameters = data.wingsuit.parameters;

              if (namespace == null) {
                var hierachy = key.split('/');

                if (hierachy.length > 2) {
                  // eslint-disable-next-line prefer-destructuring
                  namespace = hierachy[1];
                  var namespaceParts = namespace.split('-');

                  if (namespaceParts.length > 1 && namespaceParts[0].length === 2) {
                    namespaceParts.shift();
                    namespace = namespaceParts.join('-');
                    namespace = namespace.charAt(0).toUpperCase() + namespace.slice(1);
                  }
                }
              }

              Object.keys(patternDefinition).forEach(function (pattern_key) {
                if (parameters !== null) {
                  patternDefinition[pattern_key].parameters = parameters;
                }

                if (patternDefinition[pattern_key].namespace == null) {
                  patternDefinition[pattern_key].namespace = namespace;
                }

                _this5.addDefinition(pattern_key, patternDefinition[pattern_key]);
              });
            }
          } catch (e) {
            console.error('Loading failed.');
            console.error(e);
          }
        }
      });
    }
  }, {
    key: "addDefinition",
    value: function addDefinition(id, pattern) {
      this.definitions[id] = pattern;
    }
  }, {
    key: "findTwigByNamespace",
    value: function findTwigByNamespace(namespace) {
      var _this6 = this;

      var foundResource = null;
      Object.keys(this.twigResources).forEach(function (key) {
        if (key.trim() === namespace.trim()) {
          foundResource = _this6.twigResources[key];
        }
      });
      return foundResource;
    }
  }, {
    key: "findTwigById",
    value: function findTwigById(id) {
      var use = this.loadPattern(id).getUse();
      return this.findTwigByNamespace(use);
    }
  }, {
    key: "createGlobalsFromContext",
    value: function createGlobalsFromContext(context) {
      var _this7 = this;

      context.keys().forEach(function (key) {
        var data = context(key);
        Object.keys(data).forEach(function (valueKey) {
          _this7.addGlobal(valueKey, data[valueKey]);
        });
      });
    }
  }, {
    key: "createTwigStorageFromContext",
    value: function createTwigStorageFromContext(context) {
      var _this8 = this;

      context.keys().forEach(function (key) {
        var pathAry = key.replace('./', '').split('/');
        var folderName = pathAry[0];
        var mappedNamespace = '';
        Object.keys(_this8.namespaces).forEach(function (namespace) {
          var namespaceMap = _this8.namespaces[namespace].split('/');

          if (namespaceMap[namespaceMap.length - 1] === folderName) {
            mappedNamespace = namespace;
          }
        });
        pathAry.shift();

        _this8.addTwig("@".concat(mappedNamespace, "/").concat(pathAry.join('/')), context(key));
      });
    }
  }, {
    key: "getTwigResources",
    value: function getTwigResources() {
      var resources = this.twigResources;
      var result = {};
      Object.keys(resources).forEach(function (key) {
        result[key] = resources[key]["default"];
      });
      return result;
    }
  }, {
    key: "addTwig",
    value: function addTwig(namespace, resource) {
      this.twigResources[namespace] = resource;
    }
  }]);

  return PatternStorage;
}();

exports["default"] = PatternStorage;